(define (square-free n)
  (define (helper i max n)
    (if (= 0 (modulo n (* i i)))
	(square-free (/ n (* i i)))
	(if (>= i max)
	    n
	    (helper (+ i 1) max n))))
  (helper 2 (floor->exact (sqrt n)) n))

(define (simplify exp)
  (let ((exp-copy (list-copy exp)))
    (for-each (lambda (el idx)
       (let ((sqf (square-free idx)))
	 (if (not (= idx (square-free idx)))
	     (begin
       	      (set-index! exp-copy (- sqf 1)
		    	  (+ (* el (sqrt (/ idx sqf)))
			     (list-ref exp-copy (- sqf 1))))
	      (set-index! exp-copy (- idx 1) 0)))))
	      exp-copy
	      (iota (length exp-copy) 1))
    (define (truncate! lst)
      (set-cdr! (list-tail lst (- (length lst) 2)) '()))
    (define (truncate-0s lst)
      (if (and (not (null? lst))
	       (not (equal? lst '(0)))
	       (= (list-ref lst (- (length lst) 1)) 0))
	  (begin (truncate! lst)
		 (truncate-0s lst))))
    (truncate-0s exp-copy)
    exp-copy))

(define (root-list? el)
  (and (list? el)
       (every number? el)
       (every exact? el)))

(define (root-list-element-wise op)
  (lambda (rl1 rl2)
    (let ((len1 (length rl1))
	  (len2 (length rl2)))
      (simplify
       (cond ((< len1 len2)
	      (map op (append rl1 (make-list (- len2 len1) 0))
		   rl2))
	     ((> len1 len2)
	      (map op rl1
		   (append rl2 (make-list (- len1 len2) 0))))
	     (else (map op rl1 rl2)))))))


(define (set-rl-index! rl idx val)
  (if (<= (length rl) idx)
      (set! rl (append rl (make-list (- (+ idx 1)
					(length rl))
				     0))))
  (set! rl (set-index! rl idx val))
  rl)


(define (rl-ref rl idx)
  (if (<= (length rl) idx)
      0
      (list-ref rl idx)))

(define (all-pairs-between l1 l2)
  (apply append
	 (map (lambda (e1)
		(map (lambda (e2) (list e1 e2)) l2)) l1)))

(define (root-list-all-pairs op)
  (lambda (rl1 rl2)
    (define (helper result pairs-left)
      (if (null? pairs-left)
	  (begin
	    (simplify (apply + result)))
	  (begin
            (let* ((idx1-idx2 (car pairs-left))
		   (idx1 (car idx1-idx2))
		   (idx2 (cadr idx1-idx2))
	           (x (list-ref rl1 (- idx1 1)))
		   (y (list-ref rl2 (- idx2 1)))
		   (new-result
		    (set-rl-index! '()
				   (- (op idx1 idx2) 1)
				   (op x y))))
	      (helper (cons new-result result)
		      (cdr pairs-left))))))
    (helper '() (all-pairs-between (iota (length rl1) 1)
				   (iota (length rl2) 1)))))

(let ((g (generic-arithmetic numeric-arithmetic)))
  (add-to-generic-arithmetic! g numeric-arithmetic)
  (add-rule! '+ g (predicates root-list? root-list?)
	     (root-list-element-wise +))
  (add-rule! '- g (predicates root-list? root-list?)
	     (root-list-element-wise -))
  (add-rule! '* g (predicates root-list? root-list?)
	     (root-list-all-pairs *))
  (add-rule! '/ g (predicates root-list? root-list?)
	     (root-list-all-pairs /))
  (add-rule! '+ g (predicates matrix? matrix?)
	     (matrix-term-by-term +))
  (add-rule! '- g (predicates matrix? matrix?)
	     (matrix-term-by-term -))
  (add-rule! '* g (predicates matrix? matrix?)
	     (matrix-multiply-like + *))
  (install-arithmetic! g))

;; need to do it twice
(let ((g (generic-arithmetic numeric-arithmetic)))
  (add-to-generic-arithmetic! g numeric-arithmetic)
  (add-rule! '+ g (predicates root-list? root-list?)
	     (root-list-element-wise +))
  (add-rule! '- g (predicates root-list? root-list?)
	     (root-list-element-wise -))
  (add-rule! '* g (predicates root-list? root-list?)
	     (root-list-all-pairs *))
  (add-rule! '/ g (predicates root-list? root-list?)
	     (root-list-all-pairs /))
  (add-rule! '+ g (predicates matrix? matrix?)
	     (matrix-term-by-term +))
  (add-rule! '- g (predicates matrix? matrix?)
	     (matrix-term-by-term -))
  (add-rule! '* g (predicates matrix? matrix?)
	     (matrix-multiply-like + *))
  (install-arithmetic! g))
