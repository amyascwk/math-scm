\documentclass{article}

%Packages
\usepackage{amsmath,amssymb} %for math symbols

%Margins
\setlength{\oddsidemargin}{0cm}
\setlength{\topmargin}{0cm}
\setlength{\headheight}{0cm}
\setlength{\headsep}{0cm}
\addtolength{\textwidth}{4cm}
\addtolength{\textheight}{3cm}

%##############################################################################
%##############################################################################
\begin{document}
    
    \title{6.905 Final Project:\\Generic Abstract Mathematics}
    \author{Amyas Chew \and Lynn Chua \and Yongquan Lu}
    \maketitle
    
    %\tableofcontents
    
    %##########################################################################
    \section{Introduction}
        
        - Motivation
            - Role of computers in math
                - Computer Algebra Systems (CAS) take some computation load off user
                - Examples of proofs using computers: 4-color theorem, etc etc
            - Significance of project
                - Scheme allows emphasis on ideas rather than programming syntax
                - Want a flexible system allowing users to make own constructs
                - Free software and extensible so users can extend easily
                    - can keep in pace with real world progress in math community
        
        - Potential use cases
            - Convenience tool for keeping track of abstract mathematical data
            - Simple scripting language for a CAS backend
            - Possible basis for proof-assistants, proof-checkers, etc
            - ??
    
    
    %##########################################################################
    \section{Overview}
        
        - Overall structure
            - written using mit-scheme
            - Different levels of implementation:
                - Core
                - Math implementation
                - Extensions to base math
    
    
    %##########################################################################
    \section{Underlying structure}
        
        \subsection{Adapted infrastructure}
            
            As we intend for these abstract math objects to be realized over multiple domains, a priority was to build sufficiently many diverse domains to test these constructions on. Each of these are discussed briefly below.
            
            \subsubsection{Permutations}
            \label{permutations}
				
				Permutations are represented as lists of integers of length $n$; the \texttt{permutation?} predicate checks that the elements of the list are distinct and make up the range $1 \ldots n$. In this formulation $(4 1 3 2 0)$ represents the permutation that sends 0 to 4, 1 to 1, 2 to 3, 3 to 2 and 4 to 0. Note that this is not the same as the more common cycle notation, where this permutation would be represented as $(0 4) (2 3) (1)$. Our choice was a conscious decision to simplify implementation of permutation composition, but in practice translating between the two representations for display is easy.

\begin{verbatim}
(permutation? '(4 1 3 2 0))
;Value: #t

(permutation? '(3 1 a 1))
;Value: #f
\end{verbatim}
				
				The \texttt{compose-permutation} procedure takes two permutations $\sigma_1, \sigma_2$ and outputs the composition of the two. For each element $i \in \{1 \ldots n\}$, it computes $\sigma_2(\sigma_1(i))$ and writes it to the $i^{th}$ position of the output.

\begin{verbatim}
(compose-permutation '(1 3 2 0 4) '(4 1 2 3 0))
;Value 14: (4 3 2 0 1)
\end{verbatim}

            \subsubsection{Matrices}

				Matrices are implemented primitively to support group and ring constructions over rings. The matrix constructor \texttt{make-matrix} takes a list of list of elements, checks that it is well-formed (each row is the same length) and returns a tagged vector with the number of rows and columns for easy access.

\begin{verbatim}
(make-matrix '((2 1) (3 4)))
;Value 17: #(matrix 2 2 ((2 1) (3 4)))

(make-matrix '((a b) (c d e)))
;Argument is not a valid matrix.
\end{verbatim}
				
				Addition, subtraction and multiplication are implemented generically, so that elements can be in any domain ($\mathbb{Z}_p$, for example).

\begin{verbatim}
(define a (make-matrix '((1 2) (5 6))))
(define b (make-matrix '((4 1) (2 2))))
(define c (make-matrix '((1 5 2) (3 3 4))))

(+ a b)
;Value: #(matrix 2 2 ((5 3) (7 8)))

(+ a c)
;Not matrices of same dimensions

(* a b)
;Value: #(matrix 2 2 ((8 5) (32 17)))

(* a c)
;Value: #(matrix 2 3 ((7 11 10) (23 43 34)))

(* c a)
;Not matrices of compatible dimensions
\end{verbatim}
            
            \subsubsection{Radicals}
            
            	We would like to perform exact computation with radicals, for example, in order to construct groups as matrices over radicals. Existing procedures within Scheme like \texttt{sqrt} and \texttt{expt} are inexact, so we built a simple framework that allows linear combinations of integer square roots to be represented as a coefficient list, which we call a \emph{root list}. Each list is a list of cons pairs \texttt{(a . b)} representing $a \sqrt{b}$. For example, \texttt{((5 . 1) (-1 . 2) (4 . 5))} represents the sum $5 - 1\sqrt{2} + 4\sqrt{5}$. A \texttt{simplify} procedure extracts square factors out of each term and then collects and sorts like terms.
	
\begin{verbatim}
(simplify '((2 .  49/12)))
;Value: ((7 . 1/3))

(simplify '((1 . 3) (2 . 4) (1 . 18) (3. 4)))
;Value: ((10 . 1) (3 . 2) (1 . 3))
\end{verbatim}
	
				Using generic arithmetic, we are also able to support addition, subtraction and multiplication over root lists. Addition and subtraction are performed component wise, while multiplication is implemented by distributing over both root lists, collecting like terms and simplifying. Division is implemented by incrementally rationalizing the denominator.

\begin{verbatim}
(+ '((1 . 3) (2 . 9))
   '((1 . 5) (7 . 12)))
;Value: ((6 . 1) (15 . 3) (1 . 5))

(* '((1 . 2) (1 . 3))
   '((1 . 1) (2 . 3)))
;Value: ((6 . 1) (1 . 2) (1 . 3) (2 . 6))

(/ '((1 . 2) (1 . 3))
   '((2 . 1) (1 . 2) (-1 . 3)))
;Value: ((1/23 . 1) (14/23 . 2) (10/23 . 3) (2/23 . 6))
\end{verbatim}
                
                This system currently works well for square roots, but we can conceive of a system where each tagged list has another parameter to support $n^{th}$ roots as well. A simple extension to \texttt{simplify} can use $8 = 2^3$ to reduce $\sqrt[3]{56}$ to $2\sqrt[3]{7}$. We chose, however, not to implement such an abstraction as no straightforward analogue to rationalizing the denominator for division exists.
                                          
        \subsection{Math-object Datatype}
            
            - explanation of choice of structure
    
    
    %##########################################################################
    \section{Math Implementation}
        
        \subsection{Sets}
            
            - sets stuff
        
        
        \subsection{Group-like objects}
            
            - group-like stuff
        
        
        \subsection{Ring-like objects}
            
            - ring-like stuff
        
        
        \subsection{Hypergraph-like}
            
            - hypergraph-like stuff
    
    
    %##########################################################################
    \section{Specialized Constructors}
        
        To demonstrate the utility of this framework, we built further higher-order abstractions to better manipulate and construct groups in different settings. This was done specifically in a group context, but this proof-of-concept demonstrates that these constructions are possible for rings and other settings too.
        
        \subsection{Generated groups}
        \label{generated-groups}
        
        Instead of constructing a group (or monoid, or semigroup) out of an explicit set and operation, we can rely on the closure axiom and let Scheme generate the set out of a list of generators.
        
         Within \texttt{group-from-generators} is an internal recursive helper function that takes a list of elements so far and pairs it still needs to test. It then \texttt{cdr}s down the latter, each time producing an element, testing if it is a member of its list of elements so far. If so, the helper calls itself with the same list of elements and the remaining pairs to test; if not, it adds the newly found element to the list of elements so far, and appends the $2n$ new pairs to test to the remaining pairs to test before calling itself. $\texttt{group-from-generators}$ initializes this with the list of elements and all $n^2$ initial pairs. This operation, as expected, runs in $O(|G|^2)$ time, where $|G|$ is the order of the initially undetermined group. 
         
         EXAMPLES HERE
         
         It is the user's responsibility to pass this procedure a valid set of generators and an operation; the procedure will not terminate and overflow if no closure can be found over the given set of generators.
        
        \subsection{Parametrized groups}
        
        Certain infinite families of groups occur over and over again, so we built special-purpose constructor wrappers to abstract these groups.
        
        \subsubsection{Cyclic groups}
        
        A cyclic group of order $n$ may be represented as the elements $\{0 \ldots n-1\}$ armed with the operation $+ \mod n$.
        
                 EXAMPLES HERE
        
        \subsubsection{Dihedral groups}
        
        There are many equivalent ways to represent the dihedral group $D_n$ (of size $2n$), but for simplicity our implementation relies on the presentation $<p,q|p^n = q^2 = 1, qpq^{-1} = p^{-1}>$. Elements of $D_n$ are represented as tuples $(x,y)$ where $x \in \{ 0 \ldots n-1\}$ and $y \in \{0, 1\}$, and the operation $\cdot$ is defined as follows:
        
        $$(x_1,y_1) \cdot (x_2,y_2) = (x_1 + x_2 \cdot (-1)^{y_1} \mod n, y_1 + y_2 \mod 2)$$
        
                 EXAMPLES HERE
        
        \subsubsection{Permutation groups}
        
        Recall that in section \ref{permutations} we have already built up the underlying infrastructure for composing and manipulating permutations. Therefore it is easy to construct $S_n$ as the set of all $n!$ permutations on $\{1\ldots n\}$ with the operation \texttt{compose-permutation}.
        
                 EXAMPLES HERE
        
		The alternating group $A_n$, defined as the index-2 subgroup of $S_n$ consisting of all even permutations, is a bit harder to explicitly construct. We sacrifice computational runtime for simplicity and define it as the closure of all permutations $p_i$ from $2\leq i \leq n-1$, where $p_i$ switches 1 and 2 and switches $i$ and $i+1$ (see section \ref{generated-groups}).
		
		         EXAMPLES HERE
    
    	\subsection{Constructing isomorphisms}
	
		We can say that two finite groups $G_1$ and $G_2$ 
		
		need to finish
    
    %##########################################################################
    \section{Code}
        
        The latest version of the code can be obtained from \texttt{https://github.com/amyascwk/math-scm}.
        
    
\end{document}